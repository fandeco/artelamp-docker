<?php

	use fandeco\category\Category;
	use fandeco\category\CategoryExtension;
	use fandeco\category\Description;

	require_once dirname(MODX_BASE_PATH) . '/vendor/autoload.php';

	include_once __DIR__ . '/_default.php';

	ini_set("memory_limit", 1024 * 1024 * 1024 * 10);
	$LOG = [];

	/**
	 * Забор товаров из 1С для сайта artelamp
	 */
	class CrontabControllerSyncProducts extends CrontabControllerSync
	{
		/**
		 * @var bool
		 */
		private $isReport = FALSE;
		/**
		 * @var modutilitiesCsv
		 */
		private $report;
		/**
		 * @var array
		 */
		public $submits = [];
		/**
		 * @var array
		 */
		public $Categories = [];

		public function __construct(modX $modx, array $config = [])
		{
			parent::__construct($modx, $config);
			$this->report = $this->modx->util->csv();
			$this->report->setHead('артикул', 'категория', 'подкатегория', 'ошибка');
			$this->categoryValidator = new Category();
		}

		/* @var fdkNewDownloadImages $fdkNewDownloadImages */
		public $fdkNewDownloadImages;

		public function initialize()
		{
			include_once MODX_CORE_PATH . 'classes/fdkNewDownloadImages.php';
			$this->fdkNewDownloadImages = new fdkNewDownloadImages($this->modx);
			return parent::initialize(); // TODO: Change the autogenerated stub
		}

		/**
		 * @throws Exception
		 */
		public function process()
		{
			$this->print_msg('Создаем поля');
			$this->msAddFields();
			// Забираем справочник полей
			$this->print_msg('Забираем справочник полей');
			$articles = $this->submitToSite();

			$products = [];

			// Делим на 100 запросов так как 1с больше не отдаст
			$this->print_msg('Делим на 100 запросов так как 1с больше не отдаст');
			$chunkArticles = array_chunk($articles, 100);
			foreach ($chunkArticles as $k => $chunkArticle) {
				// Кэшируем по умолчанию
				$response = cacheValuesSite($this->modx, 'region_products_artelamp_it_' . $k . $this->cachePrefix, function (modX $modx) use ($chunkArticle) {
					$response = $this->send('products', [
						"artikuls" => $chunkArticle,
					]);
					return $response['products'];
				},                          $this->cache, 3600);

				if (!empty($response)) {
					$products = empty($products) ? $response : array_merge($products, $response);
				}
			}


			// Хак для категорий
			$this->print_msg('Хак для категорий');
			foreach ($products as $k => $product) {
				$category = trim($product['good_type_web']);
				if (mb_strtolower($category) === 'на ручную проверку') {
					$this->addError($artikul_1c, 'На ручную проверку');
					continue;
				}
				$sub_category = trim($product['sub_category']);
				if (mb_strtolower($sub_category) === 'на ручную проверку') {
					$this->addError($artikul_1c, 'На ручную проверку');
					continue;
				}
				if (mb_strtoupper(trim($category)) === mb_strtoupper(trim($sub_category))) {
					$sub_category = '';
				}
				if (mb_strtolower($sub_category) === 'шинопроводы' && mb_strtolower($category) === 'магнитные трековые системы') {
					$sub_category = 'Магнитные шинопроводы';
				}
				$products[$k]['sub_category'] = $sub_category;
			}


			$this->print_msg('Создание категорий');
			$this->createCategories($products);


			$this->print_msg('Создание товаров');
			$this->createProducts($products);

			$this->print_msg('Проверка на наличие опубликованных товаров');
			$this->checkCountProdcut();

			$tableProduct  = $this->modx->getTableName('msProductData');
			$tableProduct2 = $this->modx->getTableName('msProduct');
			$publishedon   = time();

			$sql     = "SELECT {$tableProduct}.id FROM {$tableProduct} 
left JOIN {$tableProduct2} on {$tableProduct2}.id = {$tableProduct}.id
where {$tableProduct}.price =0 and {$tableProduct2}.published = 1
";
			$ARTS    = $this->modx->util->arrayToSqlIn($this->submits);
			$sql2    = "SELECT {$tableProduct}.id FROM {$tableProduct} 
left JOIN {$tableProduct2} on {$tableProduct2}.id = {$tableProduct}.id
where {$tableProduct2}.published = 1 and {$tableProduct}.article not in ($ARTS)
";
			$hidden  = $this->modx->query($sql)->fetchAll(PDO::FETCH_COLUMN);
			$hidden2 = $this->modx->query($sql2)->fetchAll(PDO::FETCH_COLUMN);

			$hidden += $hidden2;

			foreach ($hidden as $product_id) {
				$SQL2 = "UPDATE {$tableProduct2} SET published = 0,publishedon = '{$publishedon}'  WHERE id = {$product_id}";
				$SQL3 = "UPDATE {$tableProduct} SET is_price = 0  WHERE id = {$product_id}";
				if ($this->modx->exec($SQL2)) {
					$this->modx->exec($SQL3);
					$cache_file = MODX_CORE_PATH . 'cache/resource/web/resources/' . $product_id . '.cache.php';
					if (file_exists($cache_file)) {
						unlink($cache_file);
					}
					$countHidden++;
				}
			}

			$this->sendReport();
			$this->print_msg('Отчистка кэша');
			$context_key = 'web';

			$this->modx->cacheManager->refresh([
												   'db'               => [],
												   'auto_publish'     => ['contexts' => [$context_key]],
												   'context_settings' => ['contexts' => [$context_key]],
												   'resource'         => ['contexts' => [$context_key]],
											   ]);
			$this->print_msg('Завершено');
		}

		/**
		 * Проверка количества товаров в категории если нету опубликованных товаров то снимаем категори с публикации
		 */
		public function checkCountProdcut()
		{
			$root_id = 2;

			/** @var pdoFetch $pdoFetch */
			$pdoFetch = $this->modx->getService('pdoFetch');


			$q = $this->modx->newQuery('msCategory');
			$q->select('id,published');
			$q->where([
						  'class_key' => 'msCategory',
						  'id:!='     => $root_id,
					  ]);
			if ($q->prepare() && $q->stmt->execute()) {
				while ($row = $q->stmt->fetch(PDO::FETCH_ASSOC)) {
					$parent = $row['id'];

					if (!empty($row['published'])) {
						$parents  = [];
						$children = $pdoFetch->getChildIds('modResource', $parent, 1, ['context' => 'web', 'class_key' => 'msCategory']);
						if (!empty($children)) {
							$parents = $children;
						}
						$parents[] = $parent;
						$criteria  = [
							'class_key' => 'msProduct',
							'parent:IN' => $parents,
							'published' => 1,
						];
						$count     = $this->modx->getCount('msProduct', $criteria);
						$published = $count > 0 ? 1 : 0;

						// Снимаем с публикации если был опубликован
						$table = $this->modx->getTableName('msCategory');
						$this->modx->exec("UPDATE {$table} SET published = '{$published}'  WHERE id = {$parent} and class_key = 'msCategory' and template <> 14 ");
					}
				}
			}

		}

		protected $errorsProducts = [];

		public function addError($key, $msg)
		{
			$this->errorsProducts[$key] = $msg;
			$this->print_msg($msg);
		}

		/**
		 * Вернет список товаров в наличии
		 * @return array
		 */
		public function getStocks()
		{
			$rows = [];
			$q    = $this->modx->newQuery('fdkPrepareStocks');
			$q->select('article,stock');
			$q->where([
						  'update_error' => 0,
					  ]);
			if ($q->prepare() && $q->stmt->execute()) {
				while ($row = $q->stmt->fetch(PDO::FETCH_ASSOC)) {
					$rows[$row['article']] = (int)$row['stock'];
				}
			}
			return $rows;
		}

		/**
		 * Вернет список товаров в наличии
		 * @return array
		 */
		public function getPrices()
		{
			return [];
		}

		public function timerStart()
		{
			$this->start_timer = microtime(TRUE);
		}

		public function timerEnd($id)
		{
			$time_str = round(microtime(TRUE) - $this->start_timer, 4) . ' сек.';
			$this->print_msg("[{$id}] UPDATE IMAGES time: " . $time_str);
		}

		/**
		 * @param msProductData $Product
		 * @return bool
		 * @throws Exception
		 */
		public function getImages(msProductData $Product)
		{
//			$this->timerStart();
			$status = $this->fdkNewDownloadImages->getImages($Product, $Product->get('article'), TRUE);
//			$this->timerEnd($Product->get('id'));
			return $status === 200;
		}

		public function createProducts($products = [])
		{
			$parents = $this->getParents();
			$this->print_msg('Получение всех остатков');
			$stocks = $this->getStocks();


			$this->print_msg('Получение категорий');
			$categoryUri = [];
			$q           = $this->modx->newQuery('msCategory');
			$q->select('id,uri');
			$q->where([
						  'class_key' => 'msCategory',
					  ]);
			if ($q->prepare() && $q->stmt->execute()) {
				while ($row = $q->stmt->fetch(PDO::FETCH_ASSOC)) {
					$categoryUri[$row['id']] = $row['uri'];
				}
			}

			$FieldMeta = $this->modx->getFieldMeta('msProductData');
			$fields    = [];
			foreach ($FieldMeta as $fi => $meta) {
				$fields[$fi] = $meta['phptype'];
			}

			$defaultProduct = [
				'class_key'    => 'msProduct',
				'template'     => 6,
				'published'    => 1,
				'createdon'    => time(),
				//				'publishedon' => time(),
				'show_in_tree' => 0,
				'uri_override' => 1,
				'cacheable'    => 1,
			];
			$this->print_msg('Обновление товаров');
			$fieldsOffset = ['alias_tl', 'submit_to_artelamp_it', 'submit_to_site', 'submit_to_divinare_it', 'submit_to_technolight', 'errors', 'title', 'description'];
			$fieldsOffset = array_flip($fieldsOffset);
			global $LOG;
			$modResourceTable   = trim($this->modx->getTableName('modResource'), '`');
			$msProductDataTable = trim($this->modx->getTableName('msProductData'), '`');
			foreach ($products as $artikul_1c => $product) {
				$this->print_msg('Обновление: ' . $artikul_1c);
				$this->submits[] = $artikul_1c;
				$category        = $product['good_type_web'];
				$sub_category    = $product['sub_category'];
				if (empty($artikul_1c)) {
					$this->addError($artikul_1c, 'Нет артикула $artikul_1c');
					continue;
				}
				try {
					[$category, $sub_category] = $this->categoryValidator->validate($category, $sub_category);

				} catch (CategoryExtension $e) {
					$this->addError($artikul_1c, $e->getMessage());
					$this->addErrorReport($artikul_1c, $e->getCategory(), $e->getSubCategory(), $e->getMessage());
					continue;
				}
				if (empty($sub_category)) {
					$sub_category = 0;
				}
				$parent_id = $this->Categories[$category][$sub_category];

				$alias              = $this->translite($artikul_1c);
				$key_search_product = $this->keyProduct($artikul_1c);
				$criteria           = [
					'Data.article' => $key_search_product,
				];

				/* @var msProduct $object */
				$ID  = (int)$this->modx->query("SELECT id FROM $msProductDataTable WHERE `article` = '{$artikul_1c}' limit 1")->fetch(PDO::FETCH_COLUMN);
				$ID2 = (int)$this->modx->query("SELECT id FROM $modResourceTable WHERE `alias` = '{$alias}' limit 1")->fetch(PDO::FETCH_COLUMN);

				/* @var msProduct $Product */
				if ($ID) {
					if ($ID2 !== $ID) {
						$this->print_msg('Какой-то пиздец');
						continue;
					}
					$Product = $this->modx->getObject('msProduct', $ID);
					if ($Product === NULL) {
						$Product = $this->modx->newObject('msProduct');
						$Product->fromArray($defaultProduct);
						$this->print_msg('Возможная ошибка');
					}
				} elseif ($ID2) {
					$Product = $this->modx->getObject('msProduct', $ID2);
					$Product->fromArray($defaultProduct);
				} else {
					$Product = $this->modx->newObject('msProduct');
					$Product->fromArray($defaultProduct);
				}
				$Product->set('pagetitle', $product['title'] ?: $artikul_1c);
				$product['description'] = $this->getDescription($product);
				$updated = FALSE;
				$data    = [];
				foreach ($product as $field => $value) {
					$field = str_replace(' ', '_', $field);
					// Все русские символы пропускаем
					if (preg_match("/[а-яё]/iu", $field)) {
						//Не пропускам поля с кривым именем
						continue;
					}

					if (!preg_match("/[a-z0-9_]/i", $field)) {
						//Не пропускам поля с кривым именем
						continue;
					}

					if (array_key_exists($field, $fieldsOffset)) {
						continue;
					}

					$type     = $fields[$field];
					$oldValue = NULL;
					switch ($type) {
						case 'string':
							$value    = trim($value);
							$value    = str_ireplace('  ', ' ', $value);
							$oldValue = trim($Product->get($field));
							$oldValue = str_ireplace('  ', ' ', $oldValue);
							break;
						case 'integer':
							$value    = (int)$value;
							$oldValue = (int)$Product->get($field);
							break;
						case 'float':
							if (is_string($value)) {
								$value = (string)trim($value);
								$value = str_replace(',', '.', $value);
							}
							$oldValue = (string)trim($Product->get($field));
							$oldValue = str_replace(',', '.', $oldValue);
							break;
						case 'boolean':
							$value    = (boolean)$value;
							$oldValue = (boolean)$Product->get($field);
							break;
						case 'json':
							$value    = !is_array($value) ? explode('||', $value) : $value;
							$oldValue = !is_array($Product->get($field)) ? explode('||', $Product->get($field)) : $Product->get($field);
							break;
						case 'text':
							break;
						default:
							$oldValue = $Product->get($field);
							if ($field !== 'description' && $field !== 'title' && $field !== 'type of instalation') {
								echo '<pre>';
								$this->print_msg('Не удалось опредеить тип {' . $type . '} поля ' . $field . PHP_EOL);
								continue 2;
							}
							break;
					}
					if ($oldValue != $value && $field != 'vendor_code') {
						if (!empty($oldValue) || !empty($value)) {
							$updated = TRUE;
						}
					}
					$Product->set($field, $value);

				}
				$Product->set('parent', $parent_id);
				$Product->set('alias', $alias);
				$data['uri'] = ltrim($categoryUri[$parent_id], '/') . '/' . $alias;
				$data['uri'] = str_ireplace('//', '/', $data['uri']);
				$Product->set('uri', $data['uri']);
				$Product->set('longtitle', $product['title']);
				$Product->set('longtitle', $product['title']);
				$Product->set('content', $product['title']);
				if ($Product->get('description') !== $product['description']) {
					$updated = TRUE;
				}
				$Product->set('description', $product['description']);
				$Product->set('artikul_1c', $key_search_product);
				$Product->set('article', $artikul_1c);
				if ($Product->isNew()) {
					$updated = TRUE;
				} else {
					$id = (int)$Product->get('id');
					if ($id && empty($Product->get('artikul_1c'))) {
						$this->modx->exec("UPDATE {$msProductDataTable} set `artikul_1c` = '{$key_search_product}' WHERE `id`= {$id}");
					}
				}

				// Получаем наличие на складе
				$stock = 0;
				if (array_key_exists($key_search_product, $stocks)) {
					$stock = $stocks[$key_search_product];
				}
				$Product->set('stock', $stock);
				$Product->set('in_stock', $stock > 0);
				if ($updated) {
					if (!$Product->save()) {
						$this->addError($artikul_1c, 'Не удалось сохранить товар');
					} else {
						$id = (int)$Product->get('id');
						if ($id && empty($Product->get('artikul_1c'))) {
							$this->modx->exec("UPDATE {$msProductDataTable} set `artikul_1c` = '{$key_search_product}' WHERE `id`= {$id}");
						}
					}
				} else {
					$this->addError($artikul_1c, 'Обновлений нет');
				}
				$product_id = $Product->get('id');
				$Product->clearCache('web');

				if ((int)date('H') > 20) {
					// Индексация товара для поиска по ключевому слову
					/* @var modProcessorResponse $response */
					$response = $this->modx->runProcessor('mgr/index/update', ['id' => $product_id], ['processors_path' => MODX_CORE_PATH . 'components/msearch2/processors/']);
					if ($response->isError()) {
						$this->modx->log(modX::LOG_LEVEL_ERROR, print_r($response->getAllErrors(), TRUE));
					}
					$this->print_msg("Загрузка изображений");
					// Загрузка изображений
					$isImages = $this->getImages($Product->getOne('Data'));

					// Записываем метку о том что изображение получено
					if (!$Product->get('is_image') && $isImages) {
						$Product->set('is_image', TRUE); // Для новых товаров
						// Ставим метку что изображение получено
						$sql = "UPDATE {$this->modx->getTableName('msProductData')} SET is_image = '1' WHERE id = " . $product_id;
						$this->modx->exec($sql);
					}

					if ($Product->get('is_image') and !$Product->get('published')) {
						// Если товар не публиковался и у него появилась цена и изображение то публикуем его
						$publishedon = time();
						$sql         = "UPDATE {$this->modx->getTableName('msProduct')} SET published = '1',publishedon = '{$publishedon}' WHERE id = " . $product_id;
						$this->modx->exec($sql);
					}
				}
			}
		}

		public function getDescription($product)
		: string
		{
			if (is_string($product['description']) && !empty($product['description'])) {
				return $product['description'];
			}
			return (new Description())->fromArray($product)->html();
		}

		public function translite($key)
		{
			return modResource::filterPathSegment($this->modx, $key);
		}

		/**
		 * Создание категорий
		 * @param array $products
		 */
		public function createCategories($products = [])
		{
			$this->Categories = [];
			$CATEGORIES_ID    = [2];
			$categories       = [];
			// Создание товаров
			foreach ($products as $artikul_1c => $product) {
				$category = $product['good_type_web'];
				if (mb_strtolower($category) === 'на ручную проверку') {
					$this->addError($artikul_1c, 'На ручную проверку');
					continue;
				}
				$sub_category = $product['sub_category'];
				if (mb_strtolower($sub_category) === 'на ручную проверку') {
					$this->addError($artikul_1c, 'На ручную проверку');
					continue;
				}
				try {
					[$category, $sub_category] = $this->categoryValidator->validate($category, $sub_category);
				} catch (CategoryExtension $e) {
					$this->addError($artikul_1c, $e->getMessage() . '-' . $e->getCategory() . '-' . $e->getSubCategory());
					continue;
				}
				if (!empty($category)) {
					if (!array_key_exists($category, $categories)) {
						$categories[$category] = TRUE;
					}

					if (!empty($sub_category)) {
						$key = $category . '/' . $sub_category;
					} else {
						$key = $category;
					}

					if (empty($sub_category)) {
						$sub_category = 0;
					}
					$categories[$key] = ['category' => $category, 'sub_category' => $sub_category];
				}
			}
			ksort($categories);


			/* @var msCategory $object */
			if (!$RootCategory = $this->modx->getObject('msCategory', 2)) {
				echo '<pre>';
				$this->print_msg('Не удалось получить ROOT категорию');
				die;
			}

			$parents = $this->getParents();


			$template  = $RootCategory->get('template');
			$root_uri  = $RootCategory->get('uri');
			$root_id   = $RootCategory->get('id');
			$menuindex = 0;
			foreach ($categories as $key => $data) {
				$alias = $link_attributes = modResource::filterPathSegment($this->modx, $key);

				$isParent  = FALSE;
				$parent_id = NULL;
				if (strrpos($key, '/') !== FALSE) {
					$tmp        = explode('/', $key);
					$tmp_parent = modResource::filterPathSegment($this->modx, $tmp[0]);
					$title      = $tmp[1];
					$parent_id  = $parents[$tmp_parent];
					$alias      = modResource::filterPathSegment($this->modx, $title);
					$uri        = $root_uri . $tmp_parent . '/' . $alias;

				} else {
					$title     = $key;
					$parent_id = $root_id;
					$uri       = $root_uri . $alias;
					$isParent  = TRUE;
				}

				if (empty($parent_id)) {
					echo '<pre>';
					$this->print_msg("Не найден {$parent_id} для категории " . $category);
					continue;
				}
				$criteria = [
					'link_attributes' => $link_attributes,
					'class_key'       => 'msCategory',
				];


				/* @var msCategory $Category */
				if (!$Category = $this->modx->getObject('msCategory', $criteria)) {

					$Category = $this->modx->newObject('msCategory');
					if ($Category) {
						$Category->set('link_attributes', $link_attributes);


						$Category->set('pagetitle', $title);
						$Category->set('longtitle', $title);
						$Category->set('class_key', 'msCategory');
						$Category->set('template', $template);

						$Category->set('uri_override', 1);
						$Category->set('hide_children_in_tree', !$isParent);
						$Category->set('createdon', time());
						$Category->set('publishedon', time());
						$Category->set('cacheable', 0);

						$Category->set('parent', $parent_id);
						$Category->set('published', TRUE);
						$Category->set('deleted', FALSE);

						if ($isParent) {
							$parents[$Category->get('link_attributes')] = $Category->get('id');
						}
					}
				}
				try {
					$Category->set('menuindex', $this->categoryValidator->getOrderByCategory($key));
				} catch (CategoryExtension $e) {
					$Category->set('menuindex', $menuindex);
				}
				$Category->set('alias', $alias);
				$Category->set('uri', $uri);

				$Category->save();
				$Category->clearCache('web');
				$ID                                                         = (int)$Category->get('id');
				$this->Categories[$data['category']][$data['sub_category']] = $ID;
				$CATEGORIES_ID[]                                            = $ID;
				unset($Category);
				$menuindex++;
				unset($categories[$key]);
			}
			$notIn = $this->modx->util->arrayToSqlIn($CATEGORIES_ID);
			$table = $this->modx->getTableName('msCategory');

			$sql = "UPDATE $table SET `deleted` = 1 where `id` not in ($notIn) and class_key = 'msCategory' and template <> 14";
			$this->modx->exec($sql);
			unset($categories);
		}

		public function getParents()
		{
			$parents = [];
			$q       = $this->modx->newQuery('msCategory');
			$q->select('id,parent,pagetitle,link_attributes');
			$q->where([
						  'class_key'          => 'msCategory',
						  'link_attributes:!=' => '',
					  ]);
			if ($q->prepare() && $q->stmt->execute()) {
				while ($row = $q->stmt->fetch(PDO::FETCH_ASSOC)) {
					$parents[$row['link_attributes']] = $row['id'];
				}
			}
			unset($q);
			return $parents;
		}

		public function addErrorReport($art, $cat, $sub, $msg)
		{
			$this->isReport = TRUE;
			$this->report->addRow($art, $cat, $sub, $msg);
		}

		public function sendReport()
		{
			if ($this->isReport) {
				file_put_contents(MODX_BASE_PATH . 'report.csv', $this->report->toCsv());
				/** @var modPHPMailer $mail */
				$mail = $this->modx->getService('mail', 'mail.modPHPMailer');
				if ($mail) {
					$mail->set(modMail::MAIL_FROM, $this->modx->getOption('emailsender'));
					$mail->set(modMail::MAIL_FROM_NAME, $this->modx->getOption('site_name'));
					$mail->address('to', 'grinev@technolight.ru');
					$mail->address('сс', 'maslova@technolight.ru');
					$mail->address('сс', 'taskaeva@technolight.ru');
					$mail->address('cc', 'nefediev@technolight.ru');
					$mail->address('cc', 'kosarev@technolight.ru');
					$mail->set(modMail::MAIL_SUBJECT, 'Неправильные категории на ' . $this->modx->getOption('site_name'));
					$mail->set(modMail::MAIL_BODY, "Ахтунг, Ахтунг, Аларм, категории неправильные<br>" . $this->report->toHtmlTable());
					$mail->setHTML(TRUE);
					$mail->attach(MODX_BASE_PATH . 'report.csv', 'report.csv');
					$mail->send();
					$mail->reset();
				}
			}
		}

		/**
		 * @throws Exception
		 */
		public function msAddFields()
		{
			$propertyReference = $this->propertyReference();
			// Сопоставление типо данных
			$arrayDiff = [
				'decimal' => 'decimal',
				'integer' => 'numberfield',
				'string'  => 'textfield',
				'boolean' => 'tinyint',
				'array'   => 'json',
				'text'    => 'textarea',
			];

			$xpdo_meta_map = [];
			include MODX_CORE_PATH . 'components/minishop2/model/minishop2/mysql/msproductdata.map.inc.php';
			$fields = $xpdo_meta_map['msProductData']['fields'];

			$fieldsProdcut = $this->modx->getFields('msProduct');


			$fieldsOffset = 'submit_to_artelamp_it,submit_to_site,submit_to_Allconsoles_it,submit_to_technolight,errors,color,description,title';
			$fieldsOffset = array_merge($fields, array_flip(explode(',', $fieldsOffset)));
			$fieldsOffset = array_merge($fieldsProdcut, $fieldsOffset);
			foreach ($propertyReference as $prop) {
				$field = $prop['field'];
				$type  = $prop['type'];
				$name  = $prop['name'];
				$field = str_replace(' ', '_', $field);
				// Все русские символы пропускаем
				if (preg_match("/[а-яё]/iu", $field)) {
					$this->modx->log(modX::LOG_LEVEL_ERROR, "Поле содержит русские буквы " . $field, '', __METHOD__, __FILE__, __LINE__);
					continue;
				}

				// Разрешено только латиница подчеркивание и цифры
				if (!preg_match("/[a-z\d_]/i", $field)) {
					$this->modx->log(modX::LOG_LEVEL_ERROR, "Поле содержит русские буквы " . $field, '', __METHOD__, __FILE__, __LINE__);
					continue;
				}

				if (array_key_exists($field, $fieldsOffset)) {
					$Field = $this->modx->getObject('msafField', ['name' => $field]);
					if ($Field && !$Field->hasField()) {
						$Field->addField();
						$Field->extension();
					}
					continue;
				}
				/* @var msafField $Field */
				if (array_key_exists($type, $arrayDiff) && !$count = (boolean)$this->modx->getCount('msafField', ['name' => $field])) {
					$Field = $this->modx->newObject('msafField');
					if ($Field) {
						$Field->set('name', $field);
						$Field->set('title', $name);
						$Field->set('type', $arrayDiff[$type]);
						$Field->set('indexes', FALSE);
						if (!$Field->save()) {
							echo "Не удалось создать поле $name";
							continue;
						}
						if (!$Field->hasField()) {
							$Field->addField();
							$Field->extension();
						}
					}
				} else {
					continue;
//					$Field = $this->modx->getObject('msafField', ['name' => $field]);
//					if ($Field) {
//						$Field->set('title', $name);
//						if ($Field->save()) {
//							$Field->updateLexicon();
//						}
//					}
				}
			}

		}

	}

