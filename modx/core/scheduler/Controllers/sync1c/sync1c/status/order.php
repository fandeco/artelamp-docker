<?php

if (file_exists(MODX_BASE_PATH . '/vendor/autoload.php')) {
    include_once MODX_BASE_PATH . '/vendor/autoload.php';
}

use Psr\Http\Message\ResponseInterface;

/**
 * Отправка статуса оплаты в 1с
 */
class CrontabControllersync1cexportstatusorder extends modCrontabController
{
    public $classKey = 'msOrder';

    public function initialize()
    {

        $this->statusSendTo1c = 2; // Статус отправки в 1с
        return parent::initialize(); // TODO: Change the autogenerated stub
    }

    protected function prepareListQueryAfterCount(xPDOQuery $c)
    {
        $c->where([
            'Log.action' => 'status',
            'Log.entry' => 2,
            'msOrder.create_payment_url_link' => true,
            'msOrder.order_payment_sent_in_1c' => false,
            'msOrder.operation_uuid:!=' => '',
        ]);
        $c->leftJoin('msOrderLog', 'Log', 'Log.order_id = msOrder.id');
        $c->groupby('msOrder.id');

        return parent::prepareListQueryAfterCount($c); // TODO: Change the autogenerated stub
    }

    /**
     * @param xPDOObject|xPDOSimpleObject|msOrder $order
     */
    protected function prepare($order)
    {
        $order_1c_id = $order->get('operation_uuid');
        $response = $this->send($order, $order_1c_id, 'PAID');
        parent::prepare($order); // TODO: Change the autogenerated stub
    }

    public function send(msOrder $order, $sync_id, $status)
    {
        $external_id = $order->get('mnt_operation_id');
        if (!$Log = $order->getOne('Log', ['order_id' => $order->get('id'), 'entry' => 3, 'action' => 'status'])) {
            echo '<pre>';
            print_r('Не удалось получить стутс лога оплаты');
            die;
        }

        $date_payment = date('c', strtotime($Log->get('timestamp')));
        $response = null;
        $options = [
            'json' => [
                "api_key" => "Fsk14g_d7kHbn3a8_fdwfKHie1n_df",
                "id" => $sync_id,
                "message" => "",
                "status" => $status,
                "date_payment" => $date_payment,
                "external_id" => $external_id,
                "data" => []
            ],
        ];


        $sync = false;
        try {
            $client = new GuzzleHttp\Client([
                'verify' => false,
                'timeout' => 30.0,
                #'base_uri' => 'https://rest.massive.ru//',
                'base_uri' => 'http://212.41.24.134:35289/bb/hs/fandeco/',
                'auth' => ['WebUserRest', '4G47r_3', 'basic']
            ]);
            $Response = $client->request('POST', 'change_status_order', $options);
            $response = $Response->getBody()->getContents();
            $response = $this->modx->fromJSON($response);
            if (!empty($response['success'])) {
                $success = $response['success'];
                $sync = is_bool($success) ? $success : ($success === 'true');
            }
        } catch (GuzzleHttp\Exception\ClientException $e) {
            $response = [
                'success' => false,
                'message' => $e->getMessage()
            ];
        }

        // В случае успешного ответа от 1С, переводим заказ в статус отправлен
        if ($sync) {
            /* @var minishop2 $minishop2 */
            $minishop2 = $this->modx->getService('minishop2');
            $minishop2->changeOrderStatus($order->get('id'), $this->statusSendTo1c);

            $order->set('order_payment_sent_in_1c', true);
            $order->save();
        } else {
            // Если ответ не успешный то вызываем ошибку
            echo '<pre>';
            print_r('Не удалось отправить статус заказа(' . $sync_id . ') PAID в 1с<br>');
            print_r($response);
            die;
        }
        return $response;
    }
}
